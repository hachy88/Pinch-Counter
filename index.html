<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pinch Counter with Sound</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        video {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 10;
            pointer-events: none;
        }

        #count-display {
            font-size: 6rem;
            font-weight: 800;
            text-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            transition: color 0.05s;
            /* 色の変化も高速化 */
        }

        #status {
            font-size: 1.2rem;
            margin-top: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 15px;
            border-radius: 20px;
            display: inline-block;
        }

        #fps-meter {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 0.9rem;
            opacity: 0.7;
        }

        button {
            pointer-events: auto;
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 1.2rem;
            font-weight: bold;
            background: #007aff;
            color: white;
            border: none;
            border-radius: 30px;
            box-shadow: 0 4px 15px rgba(0, 122, 255, 0.4);
            display: none;
            cursor: pointer;
        }

        button:active {
            transform: scale(0.95);
        }
    </style>
</head>

<body>

    <div id="container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="output_canvas"></canvas>

        <div id="ui-layer">
            <div id="count-display">0</div>
            <div id="status">Loading Model...</div>
            <button id="start-btn">カメラと音声をオンにする</button>
        </div>
        <div id="fps-meter">FPS: 0</div>
    </div>

    <script type="module">
        import {
            FilesetResolver,
            HandLandmarker
        } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

        const video = document.getElementById("webcam");
        const canvasElement = document.getElementById("output_canvas");
        const canvasCtx = canvasElement.getContext("2d");
        const countDisplay = document.getElementById("count-display");
        const statusDisplay = document.getElementById("status");
        const fpsMeter = document.getElementById("fps-meter");
        const startBtn = document.getElementById("start-btn");

        let handLandmarker = undefined;
        let lastVideoTime = -1;
        let pinchCount = 0;
        let isPinched = false;
        let lastProcessTime = 0;

        // オーディオコンテキスト
        let audioCtx = null;

        const PINCH_THRESHOLD_RATIO = 0.12;
        const RELEASE_THRESHOLD_RATIO = 0.18;

        // 音声合成エンジンの初期化（ユーザー操作が必要）
        function initAudio() {
            if (!audioCtx) {
                // クロスブラウザ対応
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
            }
            // iOSなどはサスペンド状態で始まるため再開させる
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        // 「パンッ（Pop/Click）」音を生成して再生する関数
        function playPopSound() {
            if (!audioCtx) return;

            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            // 音作り: 短く鋭い「三角形波」でクリック感を出す
            osc.type = 'triangle';

            // ピッチ: 高音から一気に下げる（アタック感）
            osc.frequency.setValueAtTime(800, t);
            osc.frequency.exponentialRampToValueAtTime(100, t + 0.08);

            // 音量: 一瞬で減衰（パーカッシブな音）
            gainNode.gain.setValueAtTime(1.0, t);
            gainNode.gain.exponentialRampToValueAtTime(0.01, t + 0.08);

            osc.start(t);
            osc.stop(t + 0.08);
        }

        const createHandLandmarker = async () => {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
            );

            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });

            statusDisplay.innerText = "Ready";
            startBtn.style.display = "inline-block";
        };

        createHandLandmarker();

        startBtn.addEventListener("click", () => {
            // 音声初期化（ここ重要：ユーザージェスチャー内で実行）
            initAudio();

            startBtn.style.display = "none";
            const constraints = {
                video: {
                    facingMode: "user",
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    frameRate: { ideal: 60 }
                }
            };

            navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", predictWebcam);
            }).catch((err) => {
                console.error(err);
                statusDisplay.innerText = "Error: " + err.message;
            });
        });

        async function predictWebcam() {
            if (canvasElement.width !== video.videoWidth || canvasElement.height !== video.videoHeight) {
                canvasElement.width = video.videoWidth;
                canvasElement.height = video.videoHeight;
            }

            let startTimeMs = performance.now();

            if (handLandmarker && video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, startTimeMs);

                canvasCtx.save();
                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

                if (results.landmarks && results.landmarks.length > 0) {
                    const landmarks = results.landmarks[0];

                    const thumbTip = landmarks[4];
                    const indexTip = landmarks[8];
                    const wrist = landmarks[0];
                    const indexMCP = landmarks[5];

                    const distTips = Math.hypot(
                        thumbTip.x - indexTip.x,
                        (thumbTip.y - indexTip.y) * (video.videoHeight / video.videoWidth)
                    );

                    const distRef = Math.hypot(
                        wrist.x - indexMCP.x,
                        (wrist.y - indexMCP.y) * (video.videoHeight / video.videoWidth)
                    );

                    const currentRatio = distTips / distRef;

                    if (!isPinched && currentRatio < PINCH_THRESHOLD_RATIO) {
                        // ONになった瞬間
                        isPinched = true;
                        pinchCount++;
                        countDisplay.innerText = pinchCount;
                        countDisplay.style.color = "#00ff00";

                        // 効果音再生
                        playPopSound();
                        triggerHaptic();

                    } else if (isPinched && currentRatio > RELEASE_THRESHOLD_RATIO) {
                        isPinched = false;
                        countDisplay.style.color = "white";
                    }

                    drawHand(landmarks, isPinched);
                    statusDisplay.innerText = `Ratio: ${currentRatio.toFixed(3)}`;
                } else {
                    statusDisplay.innerText = "No Hand";
                }
                canvasCtx.restore();
            }

            const now = performance.now();
            const fps = 1000 / (now - lastProcessTime);
            lastProcessTime = now;
            fpsMeter.innerText = `FPS: ${fps.toFixed(1)}`;

            window.requestAnimationFrame(predictWebcam);
        }

        function drawHand(landmarks, active) {
            const thumb = landmarks[4];
            const index = landmarks[8];

            canvasCtx.lineWidth = 5;
            canvasCtx.strokeStyle = active ? "#00ff00" : "#ff0000";

            canvasCtx.beginPath();
            canvasCtx.moveTo(thumb.x * canvasElement.width, thumb.y * canvasElement.height);
            canvasCtx.lineTo(index.x * canvasElement.width, index.y * canvasElement.height);
            canvasCtx.stroke();

            canvasCtx.fillStyle = active ? "#00ff00" : "white";
            [thumb, index].forEach(p => {
                canvasCtx.beginPath();
                canvasCtx.arc(p.x * canvasElement.width, p.y * canvasElement.height, 10, 0, 2 * Math.PI);
                canvasCtx.fill();
            });
        }

        function triggerHaptic() {
            if (navigator.vibrate) {
                navigator.vibrate(15);
            }
        }
    </script>
</body>

</html>